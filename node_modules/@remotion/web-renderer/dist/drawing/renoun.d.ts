/** Image format for encoded screenshot output. */
export type ImageFormat = 'png' | 'jpeg' | 'webp';
/** Options for rendering a screenshot to canvas. */
export interface RenderOptions {
    /**
     * Canvas background color. Set to `null` (or omit) for a transparent canvas.
     * When provided, the string is passed directly to `fillStyle`.
     */
    backgroundColor?: string | null;
    /**
     * Optional existing canvas to render into.
     * When omitted, a new canvas element is created.
     */
    canvas?: HTMLCanvasElement;
    /**
     * Rendering scale factor. Defaults to `window.devicePixelRatio` (or `1`).
     */
    scale?: number;
    /**
     * Crop origin X (CSS pixels) relative to the element's left edge.
     * Defaults to the element's left edge.
     */
    x?: number;
    /**
     * Crop origin Y (CSS pixels) relative to the element's top edge.
     * Defaults to the element's top edge.
     */
    y?: number;
    /**
     * Output width in CSS pixels. Defaults to the element's width.
     */
    width?: number;
    /**
     * Output height in CSS pixels. Defaults to the element's height.
     */
    height?: number;
    /**
     * Controls how `position: fixed` elements outside the captured subtree are
     * handled.
     *
     * - `none` – ignore all fixed elements outside `element`.
     * - `intersecting` – include fixed elements whose bounding rect intersects the capture rect.
     * - `all` – include all fixed elements that overlap the viewport.
     */
    includeFixed?: 'none' | 'intersecting' | 'all';
    /**
     * CSS selector used to skip elements from rendering.
     * Defaults to `[data-screenshot-ignore]`. Set to `null` or an empty string
     * to disable selector-based skipping.
     */
    ignoreSelector?: string | null;
}
/** Options for encoding a canvas to an image format. */
export interface EncodeOptions {
    /**
     * Image format to encode. Defaults to `'png'`.
     */
    format?: ImageFormat;
    /**
     * Image quality for lossy formats (`jpeg`, `webp`). A number between `0` and `1`.
     * Ignored for `png`. Defaults to `0.92`.
     */
    quality?: number;
}
/** Combined options for one-shot screenshot methods that render and encode. */
export type ScreenshotOptions = RenderOptions & EncodeOptions;
/**
 * A promise-like object representing a screenshot capture. The underlying
 * render happens once; subsequent calls to `.canvas()`, `.blob()`, or `.url()`
 * reuse the same rendered canvas.
 */
export interface ScreenshotTask extends Promise<HTMLCanvasElement> {
    /** Returns the rendered canvas. */
    canvas(): Promise<HTMLCanvasElement>;
    /** Encodes the rendered canvas to a Blob. */
    blob(options?: EncodeOptions): Promise<Blob>;
    /**
     * Encodes the rendered canvas to a Blob and creates an object URL.
     * Remember to call `URL.revokeObjectURL(url)` when done to avoid memory leaks.
     */
    url(options?: EncodeOptions): Promise<string>;
}
/**
 * Renders a DOM element into a canvas using modern browser features.
 *
 * Returns a `ScreenshotTask` that is both a Promise and provides methods
 * to encode the rendered canvas. The underlying render happens once;
 * subsequent calls to `.canvas()`, `.blob()`, or `.url()` reuse the same result.
 *
 * This implementation targets evergreen browsers only and assumes a real DOM +
 * Canvas2D environment (not Node.js).
 *
 * @example
 * // Capture handle pattern - render once, encode multiple ways
 * const shot = screenshot(element, { scale: 2 })
 * const canvas = await shot.canvas()
 * const pngBlob = await shot.blob({ format: 'png' })
 * const webpUrl = await shot.url({ format: 'webp', quality: 0.9 })
 *
 * @example
 * // Direct await returns the canvas
 * const canvas = await screenshot(element)
 *
 * @example
 * // One-shot convenience methods
 * const canvas = await screenshot.canvas(element, { scale: 2 })
 * const blob = await screenshot.blob(element, { format: 'jpeg', quality: 0.85 })
 * const url = await screenshot.url(element, { format: 'png' })
 */
declare function screenshot(target: Element | string, options?: RenderOptions): ScreenshotTask;
declare namespace screenshot {
    var canvas: (target: string | Element, options?: RenderOptions | undefined) => Promise<HTMLCanvasElement>;
}
declare namespace screenshot {
    var blob: (target: string | Element, options?: ScreenshotOptions | undefined) => Promise<Blob>;
}
declare namespace screenshot {
    var url: (target: string | Element, options?: ScreenshotOptions | undefined) => Promise<string>;
}
export { screenshot };
declare global {
    interface CanvasRenderingContext2D {
        _filterPolyfillValue?: string;
    }
}
