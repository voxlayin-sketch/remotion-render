import type { Precompositing } from './calculate-transforms';
import type { ElementAndBounds } from './elements-and-bounds';
export declare const precompose: ({ element, logLevel, parentRect, internalState, precompositing, totalMatrix, rect, isIn3dRenderingContext, }: {
    element: HTMLElement | SVGElement;
    logLevel: "error" | "info" | "trace" | "verbose" | "warn";
    parentRect: DOMRect;
    internalState: {
        getDrawn3dPixels: () => number;
        getPrecomposedTiles: () => number;
        addPrecompose: ({ canvasWidth, canvasHeight, }: {
            canvasWidth: number;
            canvasHeight: number;
        }) => void;
        helperCanvasState: import("../internal-state").HelperCanvasState;
        [Symbol.dispose]: () => void;
        getWaitForReadyTime: () => number;
        addWaitForReadyTime: (time: number) => void;
        getAddSampleTime: () => number;
        addAddSampleTime: (time: number) => void;
        getCreateFrameTime: () => number;
        addCreateFrameTime: (time: number) => void;
        getAudioMixingTime: () => number;
        addAudioMixingTime: (time: number) => void;
    };
    precompositing: Precompositing;
    totalMatrix: DOMMatrix;
    rect: DOMRect;
    isIn3dRenderingContext: DOMMatrix | null;
}) => Promise<{
    drawable: OffscreenCanvas;
    rectAfterTransforms: DOMRect;
    elementsToBeRenderedIndependently: ElementAndBounds[];
} | null>;
